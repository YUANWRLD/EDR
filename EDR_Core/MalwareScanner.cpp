#include "pch.h" 
#include "MalwareScanner.h"
#include "EmbeddedRules.h" 
#include <Windows.h>
#include <iostream>
#include <codecvt>
#include <locale>
#include <vector>

extern "C" {
#include "yara_x.h"
}

// ---------------------------------------------------------
// YARA Callback
// ---------------------------------------------------------
static void OnMatchCallback(const YRX_RULE* rule, void* user_data) {
    bool* isMatched = static_cast<bool*>(user_data);
    *isMatched = true;
}

MalwareScanner::MalwareScanner() : m_scanner(nullptr), m_rules(nullptr) {
    YRX_COMPILER* compiler = nullptr;
    YRX_RULES* rules = nullptr;
    YRX_SCANNER* scanner = nullptr;


    if (yrx_compiler_create(0, &compiler) != 0) {
        return;
    }


    if (yrx_compiler_add_source(compiler, INTERNAL_YARA_RULES) != 0) {
        yrx_compiler_destroy(compiler);
        return;
    }


    rules = yrx_compiler_build(compiler);
    if (rules == nullptr) {
        yrx_compiler_destroy(compiler);
        return;
    }

    yrx_compiler_destroy(compiler);


    if (yrx_scanner_create(rules, &scanner) != 0) {
        yrx_rules_destroy(rules);
        return;
    }

    m_rules = rules;
    m_scanner = scanner;
}

MalwareScanner::~MalwareScanner() {
    std::lock_guard<std::mutex> lock(m_scanMutex);
    if (m_scanner) {
        yrx_scanner_destroy(static_cast<YRX_SCANNER*>(m_scanner));
        m_scanner = nullptr;
    }
    if (m_rules) {
        yrx_rules_destroy(static_cast<YRX_RULES*>(m_rules));
        m_rules = nullptr;
    }
}


bool MalwareScanner::ScanFile(const std::wstring& filePath) {
    std::lock_guard<std::mutex> lock(m_scanMutex); 

    if (!m_scanner || !m_rules) return false;
    if (filePath.empty()) return false;

 
    std::wstring scanPath = filePath;
    if (scanPath.find(L"\\Device\\") == 0) {
        scanPath = L"\\\\?\\GLOBALROOT" + scanPath;
    }


    int utf8Len = WideCharToMultiByte(CP_UTF8, 0, scanPath.c_str(), -1, nullptr, 0, nullptr, nullptr);
    if (utf8Len == 0) return false;

    std::string utf8Path(utf8Len, 0);
    WideCharToMultiByte(CP_UTF8, 0, scanPath.c_str(), -1, &utf8Path[0], utf8Len, nullptr, nullptr);

  
    if (!utf8Path.empty() && utf8Path.back() == '\0') {
        utf8Path.pop_back();
    }

    bool isMalware = false;


    yrx_scanner_on_matching_rule(static_cast<YRX_SCANNER*>(m_scanner), OnMatchCallback, &isMalware);

    int result = yrx_scanner_scan_file(static_cast<YRX_SCANNER*>(m_scanner), utf8Path.c_str());

    if (result != 0) {
        return false;
    }

    return isMalware;
}


bool MalwareScanner::ScanProcessMemory(DWORD pid) {
    std::lock_guard<std::mutex> lock(m_scanMutex); 

    if (!m_scanner || !m_rules) return false;


    HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!hProcess) {
        return false;
    }

    bool isMalware = false;
    unsigned char* addr = 0;
    MEMORY_BASIC_INFORMATION mbi;


    yrx_scanner_on_matching_rule(static_cast<YRX_SCANNER*>(m_scanner), OnMatchCallback, &isMalware);

    while (VirtualQueryEx(hProcess, addr, &mbi, sizeof(mbi))) {
        bool isInteresting = (mbi.State == MEM_COMMIT) &&
            (mbi.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE));

        if (isInteresting) {
            std::vector<uint8_t> buffer;
            buffer.resize(mbi.RegionSize);
            SIZE_T bytesRead = 0;

            if (ReadProcessMemory(hProcess, mbi.BaseAddress, buffer.data(), mbi.RegionSize, &bytesRead)) {

                yrx_scanner_scan(
                    static_cast<YRX_SCANNER*>(m_scanner),
                    buffer.data(),
                    buffer.size()
                );

                if (isMalware) {
                    break; 
                }
            }
        }
        addr += mbi.RegionSize;
    }

    CloseHandle(hProcess);
    return isMalware;
}